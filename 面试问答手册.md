# 🎯 污水处理监测系统 - 面试问答手册

## 📋 项目概述（开场必备）

### Q1：请简单介绍一下你的项目

**标准回答：**
"我开发了一个基于微服务架构的污水处理监测系统，主要用于实时监测实验室的环境参数。整个系统采用Spring Cloud技术栈，包含4个微服务：

1. **认证服务**：负责用户登录和权限管理
2. **网关服务**：作为统一入口，处理路由和认证过滤
3. **监控服务**：核心业务，处理环境数据采集、实时监控和告警
4. **系统服务**：管理实验室基础信息

技术亮点包括：
- 使用WebSocket实现毫秒级实时数据推送
- Kafka消息队列实现异步处理和解耦
- Redis多级缓存提升查询性能
- 告警规则引擎支持多维度监控"

---

## 🔥 技术深度问答

### 2. 微服务架构设计

#### Q：为什么选择微服务架构？解决了什么问题？

**回答要点：**
- **单体服务痛点**：随着功能增加，代码耦合严重、部署困难、扩展性差
- **微服务优势**：
  1. **服务拆分**：按业务领域拆分，认证、监控、系统管理独立开发
  2. **独立部署**：每个服务可以独立发布，不影响其他服务
  3. **技术选型灵活**：不同服务可以选择最适合的技术栈
  4. **团队协作**：不同团队可以并行开发不同服务

**项目中的具体体现：**
```
监控服务压力最大 → 可以独立扩容监控服务
认证服务需要升级 → 不影响监控功能
新增报表服务 → 独立开发部署
```

#### Q：微服务间如何通信？

**回答：**
1. **同步通信**：HTTP/RESTful API（用户认证接口调用）
2. **异步通信**：Kafka消息队列（数据采集、告警处理）
3. **服务发现**：Nacos注册中心
4. **配置管理**：Nacos配置中心

**为什么用Kafka做异步通信？**
```
传感器数据采集 → 数据量大、实时性要求高
如果同步处理 → 响应慢、容易阻塞
使用Kafka → 生产者快速响应，消费者异步处理，还能削峰填谷
```

### 3. 数据库设计

#### Q：数据库表是如何设计的？

**回答要点：**
```sql
-- 核心表结构设计
user (用户表) - 存储用户基本信息和角色
laboratory (实验室表) - 实验室基础信息
lab_environment_data (环境数据表) - 核心业务数据
lab_alarm (告警表) - 告警记录
lab_daily_statistics (统计表) - 日统计数据
```

**设计考虑：**
1. **分表策略**：按业务域拆分，避免单表过大
2. **索引优化**：
   ```sql
   -- 环境数据表的关键索引
   INDEX idx_lab_time (lab_id, created_at)  -- 复合索引，支持实验室+时间查询
   INDEX idx_created_at (created_at)        -- 时间索引，支持时间范围查询
   ```
3. **数据类型选择**：DECIMAL精度控制、BIGINT主键、TIMESTAMP时间戳

#### Q：如何保证高并发下的数据一致性？

**回答：**
1. **Redis缓存 + 数据库**：
   - 写数据：先写数据库，再删除缓存
   - 读数据：先读缓存，缓存miss再读数据库

2. **Kafka消息保证**：
   ```java
   // 生产者配置
   spring.kafka.producer.acks=all  // 确保消息不丢失
   spring.kafka.producer.retries=3  // 重试机制

   // 消费者手动提交
   @KafkaListener
   public void handleData(String data) {
       try {
           // 处理数据
           process(data);
           // 手动提交offset
           acknowledgment.acknowledge();
       } catch (Exception e) {
           // 异常处理，消息会重新消费
       }
   }
   ```

### 4. 缓存策略

#### Q：Redis在项目中是如何使用的？

**回答：**
1. **多级缓存架构**：
   ```
   浏览器缓存 → Nginx缓存 → Redis缓存 → 数据库
   ```

2. **具体应用场景**：

   **实时数据缓存**（30秒TTL）：
   ```java
   // Hash结构存储，支持部分更新
   String key = "lab:latest:" + labId;
   redisTemplate.opsForHash().putAll(key, hashData);
   redisTemplate.expire(key, 30, TimeUnit.SECONDS);
   ```

   **历史数据缓存**（10分钟TTL）：
   ```java
   // Sorted Set存储，自动按时间排序
   String dateKey = data.getMonitorTime().toLocalDate().toString();
   redisTemplate.opsForZSet().add(cacheKey, data, timestamp);
   ```

#### Q：如何解决缓存穿透、击穿、雪崩？

**回答：**
1. **缓存穿透**（查询不存在的数据）：
   ```java
   // 缓存空值，防止频繁查询数据库
   public LabEnvironmentData getLatestData(Long labId) {
       if (cacheService.isNullValue(cacheKey)) {
           return null; // 直接返回，不查数据库
       }
       // 正常查询逻辑...
   }
   ```

2. **缓存击穿**（热点key过期）：
   ```java
   // 使用互斥锁，防止大量请求同时查询数据库
   public LabEnvironmentData getLatestDataWithLock(Long labId) {
       String lockKey = "lock:lab:" + labId;
       try {
           if (redisTemplate.opsForValue().setIfAbsent(lockKey, "1", 10, TimeUnit.SECONDS)) {
               // 获得锁，查询数据库
               LabEnvironmentData data = databaseQuery(labId);
               cacheService.set(cacheKey, data);
               return data;
           } else {
               // 未获得锁，等待并重试
               Thread.sleep(100);
               return getLatestDataWithLock(labId);
           }
       } finally {
           redisTemplate.delete(lockKey);
       }
   }
   ```

3. **缓存雪崩**（大量key同时过期）：
   ```java
   // 随机过期时间
   int randomExpire = baseExpire + new Random().nextInt(300); // 基础时间+随机5分钟
   redisTemplate.expire(key, randomExpire, TimeUnit.SECONDS);
   ```

### 5. WebSocket实时通信

#### Q：WebSocket是如何实现实时推送的？

**回答：**
1. **连接管理**：
   ```java
   @ServerEndpoint("/ws/realtime/{labId}")
   public class WebSocketServer {
       // 按实验室分组管理连接
       private static CopyOnWriteArraySet<WebSocketServer> webSocketSet = new CopyOnWriteArraySet<>();

       @OnOpen
       public void onOpen(Session session, @PathParam("labId") Long labId) {
           this.session = session;
           this.labId = labId;
           webSocketSet.add(this);
       }
   }
   ```

2. **数据推送**：
   ```java
   // 新数据产生时，推送给该实验室的所有连接
   public static void pushEnvironmentData(LabEnvironmentData data) {
       String message = JSON.toJSONString(createMessage("ENVIRONMENT_DATA", data));
       sendInfo(data.getLabId(), message);
   }
   ```

3. **前端连接**：
   ```javascript
   const labId = 1;
   const ws = new WebSocket(`ws://localhost:8080/ws/realtime/${labId}`);

   ws.onmessage = function(event) {
       const data = JSON.parse(event.data);
       updateChart(data); // 更新图表
   };
   ```

#### Q：如何管理大量WebSocket连接？

**回答：**
1. **连接池管理**：使用CopyOnWriteArraySet保证线程安全
2. **心跳检测**：定期ping/pong保持连接活跃
3. **连接数限制**：每个实验室最多100个连接
4. **异常处理**：连接断开时自动清理资源

### 6. 告警系统设计

#### Q：告警系统是如何设计的？

**回答：**
1. **规则引擎**：
   ```java
   // 多维度告警检查
   public void checkAndSendAlarm(LabEnvironmentData data) {
       // 温度告警：18-28°C为正常范围
       if (data.getTemperature() > TEMP_CRITICAL_MAX) {
           createAlarm("TEMP_HIGH", "DANGER", "温度严重异常");
       }

       // PM2.5告警：>75μg/m³超标
       if (data.getPm25() > PM25_THRESHOLD) {
           createAlarm("PM25_HIGH", "WARNING", "PM2.5超标");
       }
   }
   ```

2. **告警级别**：
   - **DANGER**：严重告警（温度>35°C）
   - **WARNING**：警告告警（PM2.5>75）
   - **INFO**：提醒告警（人数超载）

3. **告警通知**：
   - WebSocket实时推送到前端
   - Kafka消息持久化存储
   - 可扩展邮件、短信通知

#### Q：如何避免告警风暴？

**回答：**
1. **告警聚合**：相同类型告警5分钟内只发送一次
2. **频率限制**：单个实验室每分钟最多10条告警
3. **静默期**：严重告警确认后30分钟内不再重复提醒

---

## 🎯 项目亮点总结

### 必说的技术亮点：

1. **实时性**：WebSocket毫秒级推送，响应时间<100ms
2. **高并发**：Kafka异步处理，支持每秒10000+数据点
3. **高性能**：Redis多级缓存，查询响应<10ms
4. **可靠性**：消息队列重试机制，数据零丢失
5. **可扩展**：微服务架构，支持水平扩展

### 可以优化的地方：

1. **规则配置化**：告警规则支持动态配置
2. **机器学习**：基于历史数据的异常检测
3. **移动端适配**：响应式设计，支持手机访问
4. **数据可视化**：集成ECharts，提供更丰富的图表

---

## 💡 面试技巧

### 1. STAR法则介绍项目：
- **S**ituation：项目背景和需求
- **T**ask：我的职责和任务
- **A**ction：具体怎么做的
- **R**esult：项目成果和价值

### 2. 主动引导话题：
"这个项目最有挑战性的部分是实时数据处理..."

### 3. 展现思考深度：
"除了基本功能，我还考虑了系统的可扩展性和维护性..."

### 4. 诚实回答：
遇到不会的问题，可以说："这个功能目前还没有实现，但我的思路是..."

记住：**自信 + 真实思考 = 面试成功！**